#MIME

```
MINE 类型用来表示数据格式标签：
1. HTML格式：text/html
2. 普通的ASCII文本文档：text/plain
3. jpeg:image/jpeg
4. gif:image/gif

```

#常见的http方法
1. GET  从服务器获取`一份文档`
2. PUT  将请求的主题部分`存储`在服务器上
3. DELETE  从服务器上`删除`一份文档
4. POST 向服务器发送需要`处理的数据`
5. HEAD 从服务器获取文档的`首部`

#http报文格式：
1. 起始行：（方法、请求URL、版本、状态码，原因短语）
2. 首部字段
3. 主题

#URL的语法：
scheme://user:password@host:port/path;param?query#frag

#请求行
`请求方法`  `请求URL`   `版本号`
#响应行
`版本号`  `数字状态码`  `描述状态的文本形式的原因短语`
#状态码（status）
1. 100-199 信息提示
2. 200-299 成功
3. 300-399 重定向
4. 400-499 客户端错误（401需要输入用户名和密码）
5. 500-599 服务器错误

https 就是在HTTP和TCP之间插入了一个密码加密层

#keep－alive的使用
Connection：Keep－Alive
Keep－Alive：Max＝5，timeout＝120

#If-Modified-Since
将这个首部添加到GET请求中，就可以告诉服务器，只有在缓存了对象的副本之后，又对其进行了修改的情况下才发送此对象。

```
缓存验证的过程中：
1. 如果服务器对象未修改，服务器会向客户端发送一个小的HTTP 304 NOT Modified响应
2. 如果服务器对象和已缓存副本不同，服务器会向客户端发送一条普通的、带有完整内容的HTTP 200 OK响应
3. 对象被删除，如果服务器对象被删除了，服务器就回送一个 404 NOT Found 响应，客户端缓存也会将其副本删除掉
```


#保持副本的新鲜性

```
HTTP 有一些简单的机制可以在不要求服务器记住有哪些缓存拥有其文档副本的情况下，保持已缓存数据与服务器数据之间充分一致，这些简单的机制为：｀文档过期｀和服务器再验证
```

##文档过期
通过Expire和Cache－Control，HTTP让原始服务器可以给文档附加一个`过期时间`，在缓存文档过期之前，缓存可以以任意频率使用这些副本，而无需与服务器联系，除非刻苦端阻止使用缓存，一旦缓存过期，缓存就必须与服务器进行核对，询问文档囊是否被修改过，如果被修改过，则必须获取一份新鲜的副本

```
》Expires表示一个绝对的过期时间，如果过期时间已经过了，就说明文档不再新鲜了
》Cache－Control定义了一个文档的最大使用期，第一次生成文档到文档不再新鲜、无法使用位置，最大的合法生存时间 Cache－Control：Max－age＝6478478
```

##服务器再验证
仅仅是已缓存文档过期并不意味着它与原始服务器上的文档有实际的区别，只是意味着到达了核对的时间，这种情况需要服务器再验证。

```
》如果在验证内容发生了变化，缓存会获取一份新的文档，并且将其存储到旧文档的位置上，然后将文档发送给客户端
》如果文档没有发生变化，缓存只需要获取新的首部，包括一个新的过期时间，然后缓存中的首部更新就可以了
```
这是一个很好的设计，缓存并不需要为每一次请求验证文档的有效性，只有在文档过期时它才需要与服务器进行验证，这样不会提供陈旧的内容，并且节省了服务器的流量，拥有更好的用户响应时间。























